Hello, and welcome to CS111 for the summer 2025 quarter. This class is going to be offered purely asynchronously, meaning there are no live sessions at which I will be in a classroom talking to you. All of the lectures will be taped. Similarly, the exams will be offered online, and all other materials related to the class, everything from office hours to turning in labs, will be done online. will be no in-person elements of this class. So let's now talk about, in the first place, how we are going to handle a class, the administrative materials. And then we'll give an introduction to what the class is about, what sort of things we're going to be talking about in this class. Why do you study operating systems in the first place? And then we'll talk about some very basics of operating systems before we move on in future lectures to talk about more detailed issues. First, the administrative issues. Various ones. We'll talk about these on individual slides. First of all, myself. I'm the instructor for this class. My name is Peter Reier, and I have been associated with the UCLA Computer Science Department since the late 1970s. I got my PhD there. I have done a lot of research in operating systems over the course of that time, and I thus have published a lot of papers in the area, and I know certain things about operating systems based on having worked on them. This is my email address. If you want to get in touch with me, this is usually the best way to do so. We are not having any in-person office hours this quarter. I will not be on campus at times made available to you unless you make special arrangements with me, which I generally will not be too interested in doing because I don't want to have to come into campus when I don't have to. I will be offering office hours via Zoom calls. These will be set up at your request. You will have to make an appointment with me to have a Zoom session. I'm not going to have preset Zoom sessions for office hours. I will announce, I'll give you an ID when we set up the session. Now we also have a single TA for this class. Her name is Sara Khosravi. This is her email address. She will be handling certain aspects. We'll talk about the division of duties between myself and the TA shortly. she will announce her office hours, which will also be offered via Zoom. Now, there is a fairly strict division of duties between myself and the TA in this class. I do a set of things. They do a set of things. We don't work on each other's things. So for example, I will do all the lectures. I assign all the readings. I will make up all the tests. And I will grade all the tests myself. And if you have any issues related to any of these things, you don't understand something in a lecture, don't want to talk more about something that was in one of the readings, you have questions about how grading was done on a test, come talk to me. I'll deal with those. Now there are projects, labs associated with this class. Those are the TA's responsibility. So if you have any questions whatsoever about labs, go to the TA. Talk to her about these. Don't come to me and ask me about questions about the labs. If you do that, I will then tell you go talk to the TA. So you can save yourself a trip by talking to the TA directly. I'm not going to be working on project issues. There's a website of course, a typical website that is set up through UCLA for a class and this is where you will find everything associated with this class. There'll be the schedule for the readings, there'll be lectures, I will post the slides both in PowerPoint and in PDF form. The exams will be done through here, projects will turned in through here. All the materials associated with how you perform the projects will be gotten from the website. We'll probably not have the Zoom IDs for the office hours, but for live lectures, they will be posted there. Any announcements we have about changes and what's going on in the class, things I think are important for you to know, will also be located on this website. And I will, shortly before the midterm and shortly before the final exam are to be given, post a sample exam that will give you a sense of what the exams that you actually will be taking will be like. This class has prerequisites. This is not an introductory class for people who have not done any work in computer science previously. The class works on the assumption that you know certain things. And if you don't know those things, the class is going to be relatively difficult because I'm not going to be going over these things myself. I assume you already know them. The prerequisites in terms of what's in the UCLA curriculum are CS32, CS33, and CS35L. These are all introductory classes in the computer science curriculum of UCLA. 32 is one of the early programming classes. It actually has its own prerequisite of CS31. 32, you begin to talk about some of the slightly more advanced programming concepts, such as what is an object, what is a data structure, various examples of data structures and trees. CS33 is about systems programming. It gives you a brief introduction to the concept of assembly language and tells you a few things about the architecture of a computer, things about registers and memory and so forth. It also teaches you about how programs are put together, how you take complex sets of codes and build them into a working program. So how do you link together different pieces of code? What is a stack frame? What does mean, how do you go about saving registers, and why you go about saving registers, and so on. CS35L is a very, very practical lab-oriented class. It is a class that introduces you to a bunch of tools that are useful in building programming projects. Things like GitHub, and debuggers, and other tools of this nature. These are very important if you're trying to do any kind of complex programming, and it is really quite important that you understand these tools specifically for the purpose of this class, since the labs that I alluded to earlier will have serious programming components. Generally speaking, if you have not taken these classes or equivalents elsewhere, you can expect to have a hard time in this class. This is already going to be a fairly taxing class. So here's what's going to happen in the class. There are going to be weekly reading assignments. have a textbook, most of the assignments will be from the primary textbook. There are also going to be some supplementary assignments that are not from the textbook. These will be made available for free on the web. There'll be links on the web page for that week saying here's how you find this reading. All of the readings will thus be available across the web. You don't have to pay for a textbook for this class. The basic textbook is available free online. The They will be posted as recorded lectures, as I discussed. There will be no live sessions. There is no classroom associated with this class. I will not be standing up in front of a class talking about things, lecturing in this particular quarter. There are going to be individual projects that are to be done. First of all, there's also, in addition to the four projects, a warm-up project. This is basically something that is intended-- the warm-up is intended to give you a sense of, are you ready for this class or not? If you have trouble with a warm-up project, you're not ready for this class. The other projects are going to be more extensive. They're going to look at various kinds of operating system features, requiring you to interact with them, to perhaps build simple versions of things, to make alterations to operating system-like code, and so forth. There are also two exams, a midterm exam and a final exam. These will be taken online. Now you add that all up, and the reputation of CS111 in our department, in the computer science department, is that it is the hardest undergraduate CS class. And the reason is there's a lot of material in this class and it's a fast pace and this material is in many cases rather challenging. Now, most CS classes are four units. This is a five unit class. It's a five unit class because it's a harder class. There's more work. So what should you expect from this class? There are going to be lectures. You should listen to the lectures. If you don't listen to the lectures, you're probably not going to do well in the class. They're each nearly two hours long and you may want to go back and listen to some or all of them more than once. So four to six hours per week on that. There are readings. The readings are in some cases fairly short, but in some cases they're quite extensive. On the average, three to six hours for readings. The projects will take some time. There are several of those as we've discussed. They're going to take between three and 20 hours per week. A lot of time on those. And then twice we're going to have exams, the final and a midterm. I recommend studying for those. Probably you want to spend several hours studying for those, reviewing slides, reviewing the lectures, reviewing the readings. Now, this is something you sort of dive into pretty much from the very beginning of the class. So you need to keep up with this. You must not fall behind. If you fall behind, you probably won't catch up, which means you will probably not do at all well in the class. Now, as I've already said, our textbook is free. It's available online. You can download chapters from the textbook anytime you want to from the website. The textbook is by Remzi and Andrea Arpacci-Dusseau. They're faculty members at the University of Wisconsin. Long history of work in operating systems. They've written a very good book called Operating Systems-- Three Easy Pieces. That's our textbook. This is freely available online. This is the link to the basic textbook. I will be giving you links to the individual chapters that are assigned in each week's web page. As I said, there are also a few other materials that are going to be available via web links that cover topics not covered in this particular textbook. How's the class going to be graded? Here's the basis for grading. There is a class evaluation, 1% of your grade. This is just the standard evaluation. Turn in the evaluation, you get the 1%. I strongly recommend doing that. It's the easiest 1% you're going to get. A midterm exam for 20%, final exam for 26%. That introductory lab, the warm up is 9% of your grade. The other labs are 11% each. Now, how do I grade? Well, I take a look at the end of the class about overall, based on these percentages, how have people done? The people who have very, very high percentages compared to the rest of the class get very, very high grades. And the people who have lower percentages get lower grades. I do not use a formal curve. I just try to find groupings of outcomes that are similar and give them similar grades. All the scores are going to be available via my UCLA. Now, we also have the Brew and Learn grade pages. They will have grades on them. And they may tell you, oh, you're getting a B plus in the class so far. Don't believe them, because they don't have the right percentages there for the various weighting for the elements of the class. So do not count on those. Anything that appears on my UCLA, the grades that appear there for you are authoritative. If they're not the right grades, if something has been incorrectly entered, that's going to be a serious problem. There is no extra credit available at all for anything in this class. This is it. This is where the credit comes from. This will be the basis for grading. No, it's not going to give you extra points if you do better on the final than on the midterm. That will not help you. You're going to get 26% for the final, 20% for the midterm, period. So there's no point in asking me if I will change the grading basis on this basis or that basis for you. I won't. This is the grading basis. That's what it is up front. And there is no grade guarantee. I'm not making any statement saying, if you get this percentage, you will get that grade. It all depends on how the class as a whole does. Let's talk about the exams a little bit. First, the midterm. It's going to be the end of the fifth week of class on the Friday session. There will not be a recitation section that day. Instead, there'll be the exam. It can be taken any time during this day, during the 24-hour period of this day on Pacific time. And it's going to cover everything that has been discussed in class, either in lectures or in the readings, up until the exam date. Most of the material will come from the lectures on the test, but some will come from the textbook. And there are things in the textbook that I will not lecture on. So you will need to also study the textbook. However, there are materials associated as well with the projects, with the labs. No material that only appears in the project descriptions will be on the test. If it's in both readings and project descriptions, yes, it could be. But if it's only in the project descriptions, it will not be on the test. These will be online tests. You'll take them via the web. They will be multiple choice. They will be open book, open note tests. Trying to understand based on giving you these tests if you actually have gained understanding of the key concepts of the class and whether you can apply the principles that we discussed in the class to somewhat practical problems. Later, at the end of the class, of course, we have the final exam. This will be given on Friday, August 29th. No recitation section that day either. It can be taken any time you want to that day, again, on Pacific Standard Time. Scope is the entire course. There will be more emphasis on the material covered after the midterm, but there will be material from before the midterm as well on the final exam. Again, online, multiple choice, open book, open notes. And the goal is to determine, have you mastered the material of the class? Speaking a little bit more about the labs, we're going to have that warm-up project and four regular projects. All of these labs are individual. These are not team projects. And we're trying to help you understand by doing various OS features, things involving file systems and synchronization and threading and so forth. You will have to do programming for this. These are programming labs. They will require you to write code and debug code and make code work and measure how code performs. So you'll also be getting some skills, practice with skills, and building software projects. Late assignments and makeups. Now, the labs have due dates that are already set on the syllabus, which is on the website. Unless the TA tells you otherwise, those are the due dates. However, the TA has the ability-- she can change the due dates if necessary. So if you feel, for whatever reason, that there should be an extension on a lab, she is the person to talk to. And if she believes that that is true, she can give an extension for the entire class. Also, the TA will set a policy for late assignments. What happens if you turn in an assignment late? This will be entirely up to her. She will, the first week or so of the class, say, here's what the late policy is. And that will be what the late policy is. We're not going to change it. You don't come to me and say, oh, I need to have extra time on this. Go to the TA. and she will probably follow exactly the policy that she has set during that first week. For all of the other issues like, "Oh, I don't think I was graded properly on this lab. You know, explain to me why I got points off here or there." Don't talk to me, talk to her. How about the exams? If you miss an exam, you miss the exam. Too bad. Miss midterm, lose 20%. Miss the final, lose 26%. Now the exception to that is if you have a very, very good excuse and you come to me significantly ahead of time, not the day of the exam, and tell me, "Here's the reason why I can't make it, and if you can convince me that you should be given alternatives, maybe I will give you the opportunity to take the exam on some other basis. Maybe I'm not making any guarantees, but if you don't talk to me ahead of time, I guarantee you're not getting any credit for that test. Academic honesty, not my favorite topic. What's okay? What isn't okay in terms of academic honesty? Studying with friends. That's okay. That's great. That's a really good idea. Actually, a study group can be extremely helpful in learning about concepts and having deeper understanding of concepts. Going off and looking up things independently, reading another textbook, reading research papers, reading web pages, Wikipedia pages, whatever it may be, on subjects covered in the class. Of course, that's fine. That's a good idea. Go ahead, do that if you want to do that, if you want to learn more. But anything you turn in, anything associated with those labs must be your own work. So don't write lab answers for a friend. Do not copy lab answers from a friend. Do not turn in solutions to labs that you may have found on the web. You know, if you can find them, we probably can too. We're looking. And if you do research on a subject, specifically, especially if you use text from somebody else's discussion of a problem, cite your source. It is okay to cite sources, but make sure that you always make clear what you did and what you didn't do. And most of what you turn in had better be what you did. Now, whenever we see a situation in which we see a couple of assignments that look the same or look like something that has already been posted on the web from a previous quarter, what are we gonna do? We take it to the Dean of Students. That's the UCLA policy. That's what we're supposed to do. So that's what we do. Now, in particular on the projects, you are to do your own projects. They are not team projects. Do you need help on the project? That's what the TA is for. Ask the TA. She will help. In terms of coding, you must design and write all your own code except to the extent that we give you, for example, skeletons to work with from the project. That'll be made clear with any of the project materials. You do not ask others how they solve the problem. Do not copy solutions from the webs or listings and protect yourself. Do not show other people your solutions. In previous quarters, we have had situations where somebody showed their solution to another student because a student said, oh, I finished this one. How did you solve it? Show me what you did. And then that other student turned in the same assignment. Now that was bad for the student who turned in the copied assignment, but it also didn't turn out too well for the student who gave the assignment to their friend, even though they didn't intend anything wrong. You solve that problem by not giving your assignment to your friends. Okay. You can't copy answers from old assignments. We've caught people doing that as well. They've gone to the Dean of Students. Once things go to the Dean of Students, it's out of our hands. I can't do anything more about it. It's going to be decided by the Dean of Students, which means if indeed they find that you have been breaking the rules, there will be penalties. In terms of tests, well, these are online tests. You must take the test yourself. You may not have a friend take your test. You may not have somebody sitting beside you saying, "Oh, here's the answer to this." You may not call up people or send email to people saying, "What's the answer to this?" You have to take the test yourself. Now, these are open book, open note tests. You can look at all of the readings. You can look at all of the lectures. You can look at all the slides. You can look at any notes you have made yourself for this purpose. You can even go online and look on materials that are already out there online. But you must do it yourself. You may not use AI tools. You may not say, "Hey, chat GPT, "tell me the answer to this problem." That is not acceptable. And generally speaking, you have to follow the UCLA academic honesty principles. Okay, having gotten through that, let's move on to what this class is actually about, which of course is operating systems. So we'll talk about what's the purpose of this class and what's its relationship to other classes in a computer science curriculum. We'll talk about why you should study operating systems in the first place, and then, well, what is an operating system? So what are we gonna do in this class? Well, we're building on concepts from earlier classes, as I've already said, from these prerequisites. Things like data structures and what is a programming language and what is assembly language, and what are the very basic elements of computer architectures, like what is a CPU, and what are registers, and things like that. We assume you already know that, and we're going to work with that assumption in this class. And then on the other end, after you've taken this class, you'll be better prepared to take more advanced classes, things involving databases and data mining, distributed computing, networking, protocols, modeling of networks, security classes, fault tolerance classes, things of that nature. All of those are going to build on material from this class. And you'll have foundational concepts from this class. We're going to tell you what really is a process. You've heard about process. I got a process running. What's that really mean? What is the thread? How is that different from a process? What do we mean by a virtual address space? How-- what is that? And what's it used for? And how do you build it? What is a file really? You think you know what a file is, but really, what's going on there? How are you storing that data? you're accessing that data. We'll talk about things like synchronization. How do you make sure things happen in the right order? We'll talk about locking and leases and deadlock and other issues of that kind. So why study operating systems? Well, that leads to a few questions itself. First, why do you have an operating system? Why are there operating systems? Given that there are operating systems, well, why are they important? There are a lot of things we have that aren't all that important. Why are operating systems important enough to have a whole class about. And what do you get out of having an operating system? Well, let's start from the bottom of what you really have when we're talking about computing. What do you got? You got a computer. What's in that computer? What's in that box? Well, RAM. There's a memory. There's a CPU, maybe with multiple cores. There's something called a bus, which basically connects together other components, like it connects the CPU to the RAM, allows data to move back and forth. You probably have some peripheral devices. You've got a display screen, you've got a mouse or a touchpad, you've got a storage device like a flash drive or a hard disk drive. So that's what you've got. That's what's in the box. What do you want? Well, you'd like to, for example, browse the web. You'd like to look at file systems. You'd like to edit papers and other documents. You'd like to be able to play games, video games on your computer. There's all kinds of things you want to do. You want to be able to do Zoom calls like what I'm doing right now. Okay, so you got that stuff. You want this stuff. What can you do with what you've got? Can you take those things that you've got, the stuff you actually have, the hardware that's really there, and directly do the things you want to do? Well, what can you do with that piece of hardware, those various little elements of hardware we say that you've got? What can you do with them? How about the RAM? What can you do with that? You can read or write binary words, which means you can read or write 64 bits, either reading or writing. That's about all you can do with the RAM. Maybe a few other things. You might be able to zero out parts of the RAM, change its content to zero. Not much else beside that. How about the CPU? Well, you can run instructions on the CPU. What do those instructions do? They're instructions like move, which moves some data in and out of RAM. You can add together two numbers. That's good. You can jump from one instruction to another. Don't do the next instruction. Go over here instead. If you're working with a very, very advanced instruction on a very, very advanced CPU, maybe you got a square root instruction. Maybe. Many don't. What about the bus? What can you do with the bus? Well, not much. You can read. You can write. You can request sense, which basically says, tell me what's going on somewhere else on the bus. It's not all it does. It just moves stuff back and forth. It doesn't do much more than that. Okay, how about the peripheral devices? Well, for example, your flash drive. What can it do? It can read or write a block of data, maybe 4K, maybe 16K. That's all I can do. Read or write a block of data. Not really anything else. How about that mouse or the touchpad? It can report on X or Y movements. You move this much in the X direction, that much in the Y direction. clicks. You can get button clicks. That's what you can do with a mouse. Screen. What can you do with a screen? Well, you can write to groups of pixels. You can say, "I'd like these pixels to be red, please." And he said, "Pixels, perhaps, on the screen." You can erase the screen as well. That's about all you can do with a screen. What do you want to do? Well, you want to do maybe something like this. This is a trailer from a fairly old video game that you may be familiar with one of the Uncharted video games. This is what your computer is doing with that. This is actually running a bit slower than it normally does. But as you can see, there's all kinds of things going on here. Tons and tons of different stuff is going on here. This is what you want to be able to do. Now think about what's really happening in order to display this data, in order to figure out what you should display, in order to accept the commands. You're doing all kinds of physics, you're changing camera angles. The screen doesn't change camera angles. The screen says, "Light these pixels up, turn those pixels off." So, given what you can do with those basic hardware elements and what you want to be able to do, there's a big gap there. You need help. If you want to build that kind of application, and not just a game application, but anything that's a sophisticated piece of computing, lots and lots of capability in the computing, you need help. So the operating system is there to help. That's what it's for. It's to make it possible to do more complex things. It helps you perform complex operations. In particular, it worries about operations that interact. I mean, looking back at that video, you had this business where there were other characters, not the one you control, who were moving around and doing things. And maybe that was AI, maybe that was just some very simple rules saying how they did it. But somebody had to, some computation had to occur to say, move this character from here to there. Have him duck, have him shoot, whatever. And meanwhile, we're doing the same kind of thing with our controls. So our character also is moving and shooting and ducking and so forth. Now we're gonna have to use various pieces of hardware to do this. We can't do it just with the CPU. We're going to have to display things on the screen. We're gonna have to put stuff into the speakers. If we want sound that is synchronized with what happens on the screen, we're going to have to be able to deal with a touch pad. We're gonna have to locate mouse clicks. Maybe we're going to have to have typing on the keyboard. All kinds of things are going to happen. If we're dealing with, let's say, a multiplayer game with people on multiple computers, they're going to be sending stuff back and forth between the computers. We're going to have to deal with that, too. And there are probably pieces of software above the level of the operating system, below the level of the application, things like libraries, that are going to help us do things such as graphical manipulations. I want to do a 3D rotation of this particular object. Okay, you don't have to always write the code for that yourself. You could probably find a library or another piece of software that will help you do that. But that means you're going to have to hook that piece of software into the piece of software you are building in order to make it work together. So all that stuff has to happen. And you want to hide all this complexity. Now, of course, you want to hide the complexity from the user. But if you're talking about the programmer, you don't want the person who is in charge of building that program, or even the people who are in charge of building a small component of that program, because most big programs are built by teams nowadays, you don't want them having to worry about all this complex stuff. You want to hide as much of the complexity as you possibly can. And you have to make sure that since multiple things are going on, a whole lot happening at the same time, nothing is getting in the way of anything else. It's all happening in a proper, orderly fashion. The operating system is going to help you a lot with that. So what is the operating system anyway? The operating system is an example of a type of software called system software. System software is software that does not directly provide an application level of functionality to a user. It's really not exactly what the user wants to do. The user wants to play a game. The user wants to work with a spreadsheet. The user wants to edit a paper. The user wants to read their mail, that kind of thing. That's not what the operating system is doing. The operating system instead is providing support for all of those applications that are doing what the user really wants to do. So, primarily, it is working with user processes, processes that represent these programs that users want to run. It's giving them services that make it easier to build those processes, easier to run those processes, easier to make sure that the various processes that are running don't interfere with each other. In particular, the operating system sits between the hardware, those components like the RAM and the CPU and the bus that we said could do very simple things. It sits between those and the software that's trying to do complex things like play that game. It's hiding a bunch of nasty details. The operating system hides, for example, transient failures, or hides the fact that something you want to have done by one of these components isn't ready to do yet. It hasn't completed yet. You can't go ahead with it because it isn't done. It makes a whole lot of things that are quite complex appear simple by hiding the details. So, when things are going well, whether you are a programmer or a user, the operating system is a really good friend in your computer. Now, why are you studying them? Now, of course, this is to some extent an individual question, but working on the presumption that you are in some field kind of sort of like computer science, computer engineering, software engineering, some data science, that kind of thing. The reason you're studying computer science is not because we are studying operating systems, not because we expect you to become programmers working on operating systems. Very, very few people do that. There are only a very limited number of jobs in developing operating systems. Chances are pretty good that none of you will ever have one of those jobs. you probably, unless you are very, very big into Linux, are never even going to fix an operating system bug, much less program a new component of an operating system. There aren't very many operating systems that are actually in use, as we will discuss later. So that means that we don't need a whole lot of developers. There are certainly hundreds and hundreds and hundreds, maybe even thousands of software developers working on operating systems. But compared to the overall number of people who are doing programming of any kind, It's a tiny fraction. So, why do you care? Well, first of all, you got operating systems. Everybody's got operating systems. Every computing device that you work with pretty much is going to have an operating system. Your server machines, your laptop machines, your desktop machines, your tablets, your smartphones, your game consoles, set-top boxes, they all have an operating system in them. And a lot of things that you don't even think of as being computers have CPUs inside them So modern appliances, automobiles, all kinds of things, even down to Internet of Things devices like smart light bulbs. They have CPUs inside them and frequently they have an operating system that is taking care of that CPU. So we have operating systems all over the place. They're everywhere. You're going to work with operating systems whether you know it or not. How? How are you working with them if you're not actually developing them? You're not debugging them. You're not programming them. Well, you configure them, you set them up, you use their features whenever you write code. And we expect that most of you in computer science fields will end up doing some programming professionally after you finish your degrees. You're going to use operating system features to make your programs do what they're supposed to do. The operating system is providing services to people who write and use programs, and you're going to rely on those services to work properly. You're going to rely on them for memory management, for persistent storage, for scheduling, for synchronization, for communication between different processes, and for security, among other reasons. So you will be using operating systems in that sense. And another good reason. Operating systems have been around for quite a long time. They were developed in the 1950s and 1960s originally and have been developed since, improved in various ways. What this means, since they are working so close to the hardware, and they are so fundamental to what's going on in a computer is that many of the hard problems that we have seen show up in computer science have popped up first in the context of operating systems. The operating system is where we see the difficulty arising first, earliest. Therefore, it's where we have first tried to figure out how to deal with that problem. And we've typically developed solutions to these problems in the context of operating systems. So you've got a bunch of things going on on the same CPU. How do you coordinate them? Turned out to be an operating system problem. We have answers within the context of operating systems. How do you share something? How do you share the screen? How do you make sure that the screen can run the Zoom call and, if necessary, can also deal with other work that you're doing simultaneously? Operating system issue. We've solved that in the context of operating systems. How do you virtualize hardware and software? This turns out to be a very big deal. It's fundamental to cloud computing, for example. So how do you do that? Well, that was developed in the context of operating systems. If I'm communicating between two entities, like I'm on this computer, you're on that computer, you're seeing my Zoom call, perhaps even live, not in this class, but generally, how do we make sure that that gets properly organized, the communications occur in a fashion that allows us to actually understand what's going on? Operating system problem. We've looked at solutions in the context of operating systems first. And then security. How do you protect your computer resources? How do you prevent somebody from stealing your secrets? An issue that has been looked at in the context of operating systems. Solutions have been developed in the context of operating systems. So in many cases, even if you are building something that isn't an operating system, but is a complex piece of code, such as, for example, a web browser, a web server, something like that, you often go back to the operating system solutions and say, can we use those solutions to solve the problem in the context of our own system. Here's another reason you're studying operating systems and taking this class. We presume that most of you are computer scientists, not all of you, but most of you are. It's our opinion in the UCLA computer science department that somebody who has a degree in computer science should know what the hell is going on in his computer, at some degree of understanding. We know that it's so complex nowadays that nobody understands everything that's going on in a computer. But it's good to have some general notion of what's going on. That's why we have you take classes in computer architecture and in various other elements like why do you take classes in programming languages? Not so much to learn new programming languages, that's easy enough to do, but to learn how are programming languages built and what are the implications of various choices in programming language design. why you're studying operating systems as well. The operating system describes a whole lot of what is actually going on in the computer. And you need to have some degree of understanding if you want to say, "I am a computer scientist. I know how computers work." If you don't know how the operating system works, some level of detail, you don't know how computers work. All right. So what is an operating system? Well, there are many definitions for operating systems. Here's one of them. It's low-level software. It's way, way down at the bottom of the stack that goes from hardware to software to higher-level software, higher-level software applications user. Down near the bottom. What does it do? It provides better, more usable abstractions of whatever is down below it, typically the hardware. And it allows easy, safe and fair use and sharing of all the resources that are below it. How does it do this? Well, it says you can't run a program without having some hardware support. You need some memory. You need to be able to use the CPU. You need to be able to use some peripheral devices. Who's managing that hardware? Ideally, it's not the program itself, because each piece of hardware is very, very specific, got very, very complex, specific issues. Let's have the operating system manage it. This will also allow us to share the hardware in a reasonable fashion. Somebody, if you're sharing a piece of hardware, must be in charge of sharing the hardware. Somebody must be deciding. This process gets to use it now, that process gets to use it later. Got to be a traffic cop. The operating system will take care of that. Also, it has to make sure that since we are sharing this hardware, we're all using the same pieces of hardware, the same cores on the CPU, for example. How do we make sure that what I do when I'm using that piece of hardware does not leak out to somebody else, that they can't figure out what I'm doing, I can't figure out what they're doing? The operating system will take care of that as well. How are we going to make sure that the sharing that we get is fair, equitable, that the most important things get taken care of in a reasonably timely fashion, but that everybody does get some share of the shared resource? Operating systems problem. Now we also, of course, abstract the hardware. So we try to hide the fact from higher levels, such as users especially, that there's a CPU there at all, that there is something that is running these move and add instructions. They don't see that. We want to hide that from them. We want to say, yes, you can compute. Here is a program. Run your program. You will get what you want without letting them know all of the uncomfortable little details. Like, you're not really running on the core all the time. Sometimes you're not running at all. but it looks like you are. And further, it turns out that if we do things in one way, we get poor performance from the computer. If we do them in a different way, we get much better performance. The operating system tries to make sure that we get the better performance. It tries to optimize things. Further, it allows us to have higher level abstractions that applications, programmers of applications, users of applications can work with. For example, in the hardware, there is no such thing as a file. Hardware doesn't do files. Hardware does read a block of data, read 4K, write 4K. That's what it does. That's how you store data persistently. You, as a person using a computer, sitting in front of your laptop, writing a program on a server or whatever, have probably never said, "I would like to write a block of 4K of data, please." What you've said is, "Write into this file," or "Read 30 bytes out of this file." We are providing you, through the operating system, and abstraction that is ever so much more pleasant than reading or writing a particular physical location on a flash drive. We're giving you extra power from these features, things you can do that the hardware itself does not appear to be able to do. So what does an operating system look like to all the stuff that's running on top of it, to the applications, to the users? Well, it's essentially a set of services, management and abstraction services, things that say, Here's how we'll take care of everybody running on the same computer, multiple things going on at once. Here's how I'm going to provide the illusion of a file when I don't really have something that does files and hardware, et cetera. And we try to hide all of this as invisibly as possible from everything at a higher level, certainly from the users, preferably from the programmers of the applications and the applications themselves. So what does an application see when it is interacting with the operating system? Objects and services. The object that we're talking about here, and in most cases in this class, when I use the word object, I'm not really talking about object-oriented programming objects. I'm talking about the more general concept of an object, something that has a set of services it provides, something that has data representing what its state is, and so forth. So applications don't see, for example, this is the CPU. This is a word of data out there in the RAM. What they see is an object and a service that can be performed on that object. Now, the hardware does this kind of thing itself. So the CPU, for example, says, I have data types. Maybe I have integers, and I have long integers, and I have floating point numbers if I support floating point in my CPU, and so on. And you can do certain things with floating point and certain things with integers. If it's a pointer data, well, you can do certain things with pointers. OK. And you can do certain types of things, like adding and subtracting and copying from one place to another. That's what the CPU does with the objects it supports in hardware. The operating system supports things not directly in hardware, but by building higher level abstractions. So a file, as we've discussed before, that's a higher level abstraction. We have something that the operating system builds and supports that makes it look like you have a file when all you actually have is the ability to read and write 4K at a time. We have the same thing for processes. What's a process? CPUs do not have processes. CPUs do not support processes. They do move and add and jump and that kind of thing. So something has to build a process out of those primitive operations. The operating system does that. There's all kinds of other things that are abstractions, threads, devices, ports, all of that stuff. Those are all abstractions that are built by the operating system and that offer services to anybody who is working on top of them. So effectively, what an operating system has done, It has extended your computer. It has made it a more powerful machine than it was before. Now you can do more with it. So this means it's easier to work with because it's got greater power. You don't have to say, I'm going to figure out which 4K blocks out there on that flash drive are available for reading and writing. And somehow or other I'm gonna keep track of where I put things. You don't have to worry about that. You say, oh, I'll use a file. I'll open the file. I'll create the file. I'll read the file. I'll write the file. And that's all you have to worry about. and all those nitty gritty little details of, well, which 4K blocks out there on the flash driver are actually being used to hold the first few bytes of this file, not your problem. It's the operating system's problem. It'll take care of it for you. So let's take a look at where it fits in. So here's a kind of diagram we're going to be seeing in many places throughout the class in various slight variations. So down here at the bottom, we have hardware. Hardware is hardware. It's actual pieces of machinery, not necessarily moving parts. Much of it, of course, is built in silicon or in wires, but it's something where, in principle at least, you could open up the computer and you can go there and you can tap on it and say, this is the CPU, tap, tap, tap, tap, tap, and you hear a noise made. This is the RAM, tap, tap, tap, tap, tap, a noise gets made. It's real hardware stuff. It's physical, it's there. So that's what we have down at the bottom, physical stuff. And it can do certain things because it's been designed and built to do those things electronically. Things like arithmetic operations, logical operations, moving of data from one place to another, that kind of thing. Now, operating systems work on top of the hardware and an important component of the hardware is the CPU. The CPU is the central processing unit. This is the thing that runs instructions, that does all of those moves and ads and so forth. It has a, for any particular CPU, and each computer will have a particular CPU in there, or different types of CPUs. The particular CPU that your computer has in there has what's called an instruction set, which is nothing but the set of things it can do. The set of instructions that have been built into the hardware that allow it to do things. Some CPUs, for example, have the ability to do floating point operations. That's built into the hardware. Other CPUs do not have the ability to do floating point operations. That's not built into their hardware. If you go with that one of the first set and you tell it to do a floating point operation, it can do it. If you go to one of the second set and tell it to do a floating point operation, it can't do a floating point operation. It's not in the instruction set. There is no instruction that says, add two floating point numbers in those particular kinds of CPUs. Now, in modern CPUs, in most of them, the ones that are in powerful, even semi-powerful computers, you're going to have the instruction set divided into two parts, a privileged instruction set and a standard instruction set. Don't worry about the difference for the moment. just remember that there are two components, two parts of the instruction set. All right, so the operating system is going to not be the hardware, that's the hardware itself. And of course, it's not the application software either. It's not things like running Excel, or running a web browser, or running Uncharted as a game on your computer. That's application software. That's this blue stuff sitting up at the top. There are many, many, many different types of applications, a vast array. we expect a particular computer, usually, to be able to run many, many different types of applications. Okay, so we have application software. Now the application software, in order to run whatever it's doing, it's going to have to run applications. Okay, so it's going to run applications. And in order to do that, it has to run instructions. The instructions it's going to run are typically in the standard instruction set. It's going to do things like it's going to add, It's going to move data in and out of the RAM. It's going to shift data four bits to the right, or whatever it may be that this instruction does. Those instructions are going to be issued directly by the application software to the hardware, indicated by this arrow. Sometimes, however, what you're going to do in the application software is not directly saying, I have written this instruction. Really, your compiler writes the instruction. But not, this is an instruction I created. but rather you're going to say, gee, I sure would like to use a library, somebody who has already figured out how to do 3D manipulations, somebody who already knows how to perform the AES cryptographic algorithm, et cetera. I don't want to write that code myself. I'm going to use a library that already has that code written. Now, there'll be an interface to that library. Libraries are pieces of software. They're just a piece of software. And if you want to make use of the library in your application, then you have to, of course, link to the library in various ways. And once you've linked to the library, you can invoke the various operations the library provides, such as the operation that encrypts a bunch of data using AES, or the operation that decrypts a bunch of data using AES, or the operation that takes a object and rotates it 90 degrees clockwise. You'll be able to do those things simply by asking the library to do them and saying, here's the thing I want you to do it on. Great. Now, in order to do that, these libraries are available in binary form. You can see a library in source form in many cases. But when you're using it, it's in binary form. Because remember, it can't do anything on the hardware except when it's in binary form. So if you want to make use of something that's going to do a 3D rotation, you have to have 3D rotation code in a binary form, a set of instructions in machine language format. Okay, so when you call a library from your application, libc or string libraries where you're concatenating together two strings, what you're doing is calling a routine that is built into the library that is in at that point, machine language instructions that gets linked, combined with your program so that you can concatenate two strings, for example, by simply calling that function in the library. That goes through something is called the application binary interface. The library is kept on your computer in binary form. So you hook up to the library from your application using the binary interface to hook to its binary. Great. Now, the library of course is just going to have to run some instructions to do the concatenation of the strings, for example. How does it do that? Well, it does that by issuing instructions. It's the only way you can do anything active on a computer. You gotta issue instructions to the CPU. So it'll issue instructions saying, here's how I want you to go about concatenating these two strings. And almost always, those instructions are going to be part of the standard instruction set. Same instructions you could have run from the application software yourself. You could have written everything that's in the library. You could rewrite everything in the library, typically yourself, and it would be just as effective if you wrote it properly, if you wrote it well, as the library. Just save yourself the trouble of having to write that because somebody's already done it. Use their version, not yours. That's what libraries are about. Okay, so the library is typically calling things from the standard instruction set. Except, once in a while, you're going to have to do something that the library isn't allowed to do. What can't the library or the application actually do? Well, you remember I said that the operating system is sitting on top of the hardware? Any interaction with the hardware other than running a CPU instruction, which may actually also go out to RAM and get something out of RAM or put something into RAM, anything else dealing with the hardware is going to be something that only the operating system is allowed to do. Remember that privileged instruction set? We had the standard instruction set that anybody can run and the privileged instruction set. Only the operating system can run the privileged instruction set. No other code in the computer can run the privileged instruction set. So if you need to do something that requires the use of the privileged instruction set, you can't do it yourself. So how do you get it done if you need to do such a thing? For example, you want to display something on the screen. You can't display something on the screen usually from the application directly. It's not allowed to do that. How would you do it? Ask the operating system to do it. Get in touch with the the operating system and say, "Hey, operating system, I would like you to do this thing for me. Please put this on the screen." The operating system, since it can run the privilege instruction set, can make that happen. It can say, "Yes, I can run a privilege instruction that will result in that information appearing on the screen, and this message being sent across the network interface, and this data being written to the flash drive or whatever it may be, that interacts with the hardware." In order to do that, you have to get to the operating system. In order to get to the operating system, you go through something called the system call interface. When any code in your computer, whether it be your application or a library, wants to do something that it is not itself allowed to do, it makes what's referred to as a system call. It calls the operating system. It says, here, operating system, I need you to do something for me. Here's what I need you to do. Please do it for me. That goes through a special interface. When you get through the special interface, you are then running operating system code. When you're running operating system code, you can use the privilege instruction set, or more precisely, the operating system can use the privilege instruction set on your behalf. And perhaps assuming that you asked to do something that's legal to do, we'll do so. And it can then access whatever piece of the hardware it needs to access. So what is special about this operating system? Well, the operating system is in control of the hardware. The operating system has the ability to do whatever it needs to do with the hardware. Other things cannot, the operating system can. So among other things, when you have a computer that is completely shut down and you start the computer up, we go through a process that's called booting. Booting is the process of going from I'm not running to I'm ready to run and do everything I can do. That's the booting process. One of the very first things that's going to happen during the booting process is it's going to start up the operating system. The operating system will then take control of all the hardware, and then it'll start doing other things, like starting up processes on behalf of the users. So the operating system gets any form of access to the hardware before other pieces of software do. Further, the operating system is always there. Now, you've got to remember that if we're talking about, example, let's say a single core process CPU, where it's only got one core, it can run one set of instructions at a time. If you have 300 applications in the operating system all running on that single core, there's only one thing happening on that single core at any given moment. Either it's running one of the 300 applications or it's running the operating system, but not both. And not two of the applications at the same time. If you things at a time. But generally speaking, when we say that the operating system is continuously running, we don't mean that at all moments there is some component of the hardware that is running operating system instructions. What we really mean is that the operating system is there and is ready to run and is ready to take over when it should do so, which is certainly when a system call is made and sometimes at other times as well, even if nobody's made a system call, as we will see when we talk about various issues like scheduling. So the operating system must always be there and ready to run. If your operating system crashes, well, we'll talk about that in a moment. The operating system has complete access to the hardware. It can do pretty much anything the hardware can do. Nowadays, on certain CPUs, there are a few caveats to that. In some cases, CPUs have been built so they have what's called a enclave, a security enclave. This is a piece of hardware that does not allow the operating system to get complete access to what's in the hardware. The operating system can perhaps ask the security enclave to do things for it. The enclave may or may not do those things for it, but the operating system cannot force it. This is very, very special and not something you usually have to worry about. For most purposes, you could assume that the operating system has total control of the hardware, which means, among other things, that the operating system has a bug and does something wrong to the hardware, well, gee, you're kind of screwed, because the hardware does whatever the operating system says. If the operating system said to do something dumb, something harmful, hardware does the dumb, harmful thing. Okay, now this means among other things, that all that RAM, all of the data sitting in RAM, the operating system can get to that data if it wants to get to that data. It doesn't matter which application owns that data, which application is using that data, it's code, it's stack, it's heap, whatever. matter. The operating system, if it wants to, can access that data. The operating system is going to mediate the attempts by applications to use hardware. It's going to say, "You want to do this with the hardware? Yes, you may do it. You want to do that with the hardware? No, you may not do it." It's going to say yes or no, and when it says yes, it's going to make the appropriate thing happen. And when it says no, it's going to be quite sure that the application will not be able to access that hardware. So it doesn't have to do what the system call from a particular application code tells it to do. It can look at that application code's request and say yes or no, and it can refuse it. The operating system as a result of these characteristics must be trusted. This means your applications must rely on the operating system to behave properly, to do what it is supposed to do. To do no more, to do no less. We're going to store a whole lot of critical data in the operating system itself. Some portion of the memory will be used to hold data associated with the operating system. That data is critical to proper execution of all the applications on the machine. Things go wrong with that data, we got serious problems. So we have to trust the operating system to take care of that data and to use it properly, to create it well, to manage it well, to remove it well when we're finished with it, etc. Also, the operating system has a set of interfaces, those system calls. There are a bunch of system calls each operating system supports. The system call says if you do the following thing, if you make the following system call with the following parameters in the following situations, I, the operating system, will take the following response and will do what you requested to do. We expect that an operating system will always follow its interface, that it can be trusted, that it will act in good faith, that it will not lie, that it will not refuse to do something it should be able to do. That is an expectation that all the higher level software libraries, all the way up to applications, expect to see. So operating systems must have that characteristic. We already mentioned that we're relying on the operating system to be available whenever we we need to do something. On modern computers, if the operating system crashes, if there's a bug in that operating system and the operating system can no longer execute properly, that machine is done. That machine has crashed. All the applications, even though they themselves may not have had any bugs in them, they're all going to fail. Everything is gonna fail from the moment the operating system crashes. It takes down the whole machine. Typically you can reboot and start all over again, But once the operating system crashes, all the state that you had at the moment it crashed is typically gone. So this implies your operating system better not crash. It's a disastrous result on the computer if your operating system crashes. Some of you, if you're old enough or have experience with people who are older, may have heard of the blue screen of death. That's what happened when Windows used to crash. And it was very, very, very unpleasant when it happened. Modern operating systems, including modern Windows, rarely, very, very rarely crash. They may run into other problems, but they try very hard not to crash. Now, let's talk a little bit more about instruction set architectures. Remember, we have this instruction set for any CPU. Which particular instruction set we have on which CPU is a matter of the instruction set architecture. How have the people who built that CPU chip, the hardware designers who designed and built that CPU chip, how have they outlined what their instruction set looks like? So for any CPU chip, there will be a fixed set of instructions that that CPU can perform. It can do those. It can't do any others. And that doesn't change typically. Now, the way this is actually done is you issue a command by saying, here is a word of memory, something sitting in RAM. There's a bit pattern in that word. That bit pattern indicates which of the instructions you wish to perform of the several instructions that are supported by this particular chip. It is nothing but a set of bits. OK. So there's a particular bit pattern that says, here's the bit pattern that means add. Here's the bit pattern that means jump. Here's the bit pattern that means halt, and so forth. Now, there's not just one instruction set architecture out there. There are a lot of them. There are many, many, many different instruction architectures. What's different about them? Well, some of them have different word widths. Words are how much data a CPU can operate on in one instruction. In old machines, that was 8 bits. Then it became 16 bits, then 32 bits. In modern machines, it's frequently 64 bits. You can work on 64 bits at a time. You can add, for example, two 64-bit numbers in one instruction. Now, this also relates to the bus, that thing that connects things together. Buses are essentially sets of wires that move data from one place to another. How much data can they move in one operation? That's called the bus width. Typically, whatever the word length is, is also going to be the bus width. You're going to be able, if you have a 64-bit CPU, to have a bus that can move 64 bits at a time. So depending on how big the word is, you're going to have a different instruction set architecture. There are other features as well. So for example, some CPUs are built to burn very, very little power. Situations where you're relying on batteries or where you have, for other reasons, a very limited energy budget. There are CPUs that are designed for that purpose. There are others that are designed to do particular kinds of operations, like digital signal processing. That's what DSP means. Some of them support floating point operations. Some do not. There are also competitive reasons. Chips are built by particular companies, Intel for example. And in particular, when a company says, "I've got this chip," it probably says, "Well, yes, this is my current CPU chip. "A couple of years from now, "I expect I'm going to have a better chip. "I want it to be kind of like my old chip." And the reason that's important is of course, if somebody is running the old chip, they run software that works on the old chip on that instruction set architecture. If you wanna sell them a new chip, you don't wanna say, "Oh, all that software you had, throw that software away, it's no good anymore. You're going to have to replace all your software. You want to say, you can take the software that ran on our old chip and move it to our new chip, and it'll still run, and it'll probably be better. It'll be faster, et cetera. So this is a competitive reason. You have a line of CPUs, one after another after another, that are all related to each other and that typically have somewhat degree of backward compatibility on their instruction set architecture. And this is typically done on a company-wide basis. So Intel versus some of the other companies that build CPU chips. So we have families. So some of them add new features as they go from one model to another. So there's maybe more instructions in the more recent instruction set architecture, but they still have all the old ones as well. Sometimes they add things that aren't necessarily instructions, but they remain upward compatible. So typically, it is regarded as a very, very big deal to go from one instruction set architecture to a non-compatible one. A few years ago, Apple went from running Intel stuff to running their own form of CPU architecture, which was a totally different instruction set architecture. That was a big deal. That was very, very major for performing this transition. So you really want to avoid doing that if you're one of these people who manufactures hardware. Apple got away with it because they sell boxes that contain their own software and hardware. It's If you have a non-matching ISA, if you've got a program that has been written to match a particular ISA, you try to run it on a computer that has a different ISA, it does not work. It crashes if it runs at all. Typically, we try to avoid even trying to run non-compliant applications on a particular ISA. Okay, now we already talked about the fact that instruction set architecture is typically divided into two pieces. The privileged and the general instruction set. This is very, very common. Most ISAs do this nowadays. So anything that you can run on your computer can use any instruction in the general instruction set. You want to do an ad, put in a location in your program that contains the instruction with a bit pattern for ad for that ISA, and you run the ad without a problem. It just directly runs the ad instruction. But what happens if you try to run the privileged instruction when you're not a privileged piece of code, when you're just an application? Remember, the operating system is privileged. It can run the privileged instruction set. Everybody else isn't, they can't. What happens if you try? Because after all, there's no secret about what the bit patterns are that represent the privileged instructions. They're out there in a form where anybody who's interested can look and say, oh, here are the privileged instructions for the most recent Intel chip. What happens if I write a piece of code running as an application that tries to use one of those privileged instructions? Well, at any given moment, the CPU is running in one of two modes, privileged or non-privileged. If it's running an application, it's running in non-privileged mode. If you try to perform a privileged instruction when you were in non-privileged mode, the system rejects it. The hardware says, no, you cannot run that instruction. Typically, it'll cause your program to crash. So only when you are in privileged mode can you actually successfully run the privileged instructions. You can always ask if you want to. But generally speaking, if you weren't allowed to, the mere fact of asking to run a privileged instruction when you can is going to lead to your program ending suddenly. OK. And the reason for this is because we do not trust applications to make proper use of the power of the privileged instructions. we don't think they're going to do it right. And this is reasonable because anybody can write an application that does anything. It can have all kinds of bugs. It can try to do malicious things. Why should we let it do things that we shouldn't allow it to do? So we don't. OK, now, while the instruction set architecture is clearly a very important component of any computer, it's not the entire computer. Because the instruction set architecture is almost entirely about the CPU. And there are many other components, many other pieces of hardware that are in a typical computer that aren't the CPU. They're hardware. They're part of the computer, often critical parts of the computer, but they're not part of the CPU. So the computer is defined by more than its ISA, more than its CPU. So things like interrupt controllers, DMA controllers, memory management units, I/O buses, all this is stuff that may be a little bit foreign to you. We'll talk about many of them in the future. Things like BIOS, which is how you do the booting of the computer, how you configure, how you do multiprocessor and interconnect support, how you make sure that if you have four cores running, you don't mess up what's happening in RAM because two cores are doing something at the same time, apparently. All that is a little bit beyond what the ISA does. Then of course, there are all of the other devices. There are things like your keyboard and your mouse and your network card and your speakers microphone and your camera and your clock and all kinds of other things that are not necessarily part of the CPU. You typically aren't part of the CPU. So these are important parts of the computer. You know, on my laptop computer, if I did not have a touchpad, if I did not have a screen, if I did not have a camera to talk to you and microphone to pick it up and speakers to hear what is being sent back to me on the computer, I wouldn't have a complete usable They're important parts of the computer, but they're not part of the CPU. So when you add together everything that is in a particular box that is a computer, like the laptop I'm using at this very moment, the combination of the CPU with its ISA and all the other devices that are actually in this box represent what is called a platform. The operating system runs on platforms. It does not run purely on an ISA, it runs on platforms. So the operating system needs to know, for example, well, what kind of screen have I got? Do I have a wireless network device? Do I have a wired network device? Do I have both? How about Bluetooth? Have I got Bluetooth? And what kind of storage device have I got? Is it a flash drive? If so, how big a flash drive is it? And all of these other issues are going to be very, very important for the operating system to properly control the computer. So it's going to have to know about what is the platform, not just what is the ISA, but what is the platform. And there's a lot of different platforms out there. Okay, now another issue of course is, let's say that I'm in the business of building operating systems. I'm Apple, I'm Microsoft, I'm the people who create Linux, there are various other people who build operating systems. Clearly, my operating system needs to run on some particular ISA in some form, but I would like to actually have versions of my operating system that run on multiple different ISAs. Microsoft is, of course, very big on this. Microsoft wants to be able to run on all the Intel chips, all the PowerPC chips, et cetera, et cetera, et cetera. So if I want to make the most possible money off my operating system, I want it to run on a lot of stuff, many, many different pieces of hardware. This is important because customers have a particular computer. That computer has a particular CPU. That CPU has a particular ISA. If your operating system will run on that ISA, you might be able to sell it to that particular user. If your operating system will not run on that ISA, that user is not interested in your computer because he can't run your software, your operating system on his computer. Why would he buy it? So if you're in the business of selling operating systems, as say Microsoft is, you want to run on a lot of different ISAs. OK, this means that you're going to have to do something that says, well, I'm going to have people who build applications that run on my operating system because it's going to offer the system call interface. I want them to be able to run on my operating system regardless of what ISA we have underneath. So what do I do? Well, I better, as the operating system developer, abstract away all of the details of the ISA that I can, hide all of those issues, and preferably hide as many of the platform issues as I possibly can. So I want to, in my operating system design, make the minimal assumptions I possibly can about what hardware is going to be in the box that runs this particular operating system. I want the general framework, everything that I do in terms of how I build my operating system, how I connect together the pieces, to be independent of hardware. I don't want to worry about that. So for example, in the file systems, I could be using a flash drive, I could be using a hard disk drive. I want the same code for my file system to run on both of those, even though they do very, very different things and behave in different ways. I want to avoid hardware assumptions in most of my operating system. Now it'll turn out I cannot avoid all of them. There are gonna be places in my operating system where I have to know what ISA I'm running on, perhaps other platform issues. I can't run properly as an operating system without knowing those, without dealing with them in the appropriate fashion. I got to accept that. But I want to limit my specific requirements on understanding the hardware to those particular elements of the operating system. I want them to be as little as possible, not very much at all. I want most of the code of the operating system to be independent of whatever particular ISA, and preferably platform, that I happen to be operating on. And I need to be careful about that. So for example, if I say I would like Windows to run on top of 32-bit machines and 64-bit machines, well, I better make sure that in the code that represents Windows, I don't write code that assumes that all of my integers are 64 bits, because there are 32 bits on some of the machines I'm trying to support. So I'm going to have to be very careful about those kinds of issues. Now, there are quite a few different ISAs, but there's a relatively limited number of popular ones. So maybe you could just do something special for those. What about platforms? Well, that's going to be a lot more difficult, because there are hundreds of different models of screens, hundreds of different models of flash drives, hundreds of different models of network cards. And if I'm Apple, I can say, well, I build hardware. This is the hardware. This is what I put in this one. But if I'm Microsoft, I say, I'd like to run on your computer. What do you happen to have? And you could happen to have a very odd collection components, and I'd really like to still be able to run your hardware. I want to fit on multiple platforms. How am I going to do this? Well, somehow or other, if I'm selling operating systems, I have to get you the operating system. I have to give you the operating system. Now, as we already said, if I give you a piece of code that doesn't run on your instruction set architecture, you can't run the piece of code. So clearly, if I'm going to give you the operating system and you're going to run it on your computer. I had better give it to you in a form that will run on your computer. Typically, we do not want our users or even the people who are installing operating systems on computer to compile up the operating system, to go from source code to the binary. What we want to do is say, here is a binary, which means here is something that's already in machine language, which means in turn, here is something specific to a particular ISA. That's how I I'm going to give them a binary distribution, not a source distribution. You may say, "Oh, but Linux is open source. I can get an open source distribution of Linux." Sure you can, but for the vast majority of the people who run Linux, they do not take the source code, compile up the source code, and install it on their computer. Instead, they go to somewhere like Red Hat, and they get a binary distribution that has already been compiled to run on a particular ISA, which implies they better get the right one. Because if they get a PowerPC version and they're running on an Intel chip, it isn't going to work. So the binary distribution model is the fundamental model that operating system developers use to get their operating system out to their customers. Binary of course is a derivative of source. There's source code somewhere. In the case of Microsoft, this is sitting in Microsoft's private company offices and in their labs, and it is only available typically to people who work for the Microsoft operating development team. Nobody else gets to see it. They only get to see the binary. If it's Linux, of course, everybody in principle can see it. And even in practice can see it. You want to go out and see the source code for Linux, go online, you get the source code for Linux. But regardless, one way or another, somewhere there is source code that represents the operating system. It gets compiled down into binary. The binary distribution is linked together, put together properly. So now, if you put it on a computer and you boot that computer in the appropriate way, you'll start running that operating system, assuming it's the right ISA. Okay, so this is the way we do things. So typically, of course, for things like Linux and Windows, there will be multiple different binary distributions, at least one per ISA. Sometimes there are other hardware features they also want to have, such as, for example, they may say for this distribution you require a certain amount of RAM, if you have less RAM you need to use this other distribution, for example. Now that's great, but remember I said there are hundreds and hundreds of different pieces of hardware of various kinds, the flash drives, the keyboards, the mice, the network cards, the microphones, the speakers, all that stuff. Many, many different pieces there. How are we going to make sure that we can actually have the appropriate operating system support for your platform, not just for your ISA, there's a limited number of those, you can just say it's It's got to be this ISA, get that one. But what about for your platform? We cannot possibly have a separate configured operating system sitting on the shelf in binary form that matches each and every possible platform everybody could have. There would be literally millions of them. That doesn't make any sense. So what do we do? We give you a version of the operating system that is correct for your ISA, but that is not necessarily properly configured at the moment we give it to you for all of your other devices, for your flash drive, for your network card, for your mouse, for your keypad, etc. So what are you going to do about that? Well, what we're going to have to do about that is binary configuration. When the binary first gets installed on your computer, the very first thing the operating system is going to do is say, "Okay, I have the right ISA. I'm running code. That's fine. But what the hell is on this computer? What kind of keyboard have I got? What kind of screen have I got? What kind of camera do I have? What kind of microphone do I have? What kind of speakers do I have? Et cetera, et cetera. You're going to have to figure that out. And once you know that, once the operating system has looked around and said, "Here's what's on the computer," it's going to have to say, "Well, now I need some code that works for this screen, for this microphone, for this flash drive, for this particular network card, et cetera, et cetera." Those pieces of code are called device drivers. All these special pieces of hardware, all these individual components that are part of the platform other than the CPU and the RAM and so forth. They're called devices. For every device, you need code. And that code is called a device driver. So what we're going to do to configure a binary for a particular computer is we're going to take the binary that is generic for that ISA, figure out what devices you have, find device drivers that match those particular devices you happen to have in that platform, and plug those into the operating system. which means we're gonna have a pluggable model for device drivers. So we plug them in. Now, of course, first of all, we have to figure out what do we got? How do you figure out what you've got? The very, very old fashioned way is you have some smart system administrator come in and say, okay, this is what we got on this computer. I will type up a configuration file. And then when we boot it'll look at the configuration file and figure out what we got. That's not a good way to do it. You know, most people don't happen to have a suitably smart system administrator floating around ready to do that for them. So what do we do instead? We have the operating system figure it out for itself. How does it figure it out? Well, all of these devices are connected via a bus. There's actually more than one bus in typical modern computers, but fundamentally all of the buses to some extent connect to all of the other buses, or more precisely everything connects to the main bus. The operating system, when it boots up for the first time, can go out to the buses and can say, "Hey, boss, tell me, what do you got at this port? What do you got at that port? What do you got at this other port?" where each port is where a device might be attached. And the devices are each set up so that they say, "Well, when I'm sitting on this hardware port, if somebody sent me the following signal, I can say, 'I am the following model of network card. I am the following model of flash drive. I am the following model of touchpad,' whatever I may be." And that information can then go back to the operating system. The operating system can collect it from all the ports. This is called automatic hardware discovery using self-identifying buses. Modern buses have this feature. And modern devices that you attach to the modern buses have this feature. This then allows the operating system to make an inventory of everything that's out there in terms of hardware. So then it finds and loads the required device drivers. We'll worry later about how it does that. Not today's topic. That isn't all, because there are other things you have to worry about. So for example, you can have varying amounts of RAM on different computers. And as I stated, sometimes you'll have a different binary distribution for different amounts of RAM, but more commonly, you have one binary distribution. Then you're going to look and say, "How much RAM have I got?" That's something else you can find out from the bus. You can figure that out automatically. You know, "I've got 500 gigabytes or whatever it may be. Okay, now based on that, the operating system is then going to have to say, well, that's my overall budget for running applications and for taking care of all the other activities that I, the operating system, must perform. That's how much I've got. Now I'm going to have to divide that up and say, I'll use this portion of it for my own purposes, to keep track of operating system data structures, for example. And this portion I can use to support applications. I can give them space for their code, space for their stack, space for their heap, etc., etc., etc. Sometimes it'll turn out that I haven't divided things up in the proper way. In particular, when I say, "I'm going to take this part for my operating system uses," I probably will divide up that part into subparts, pools of buffers for various purposes, which we'll talk about later. I may make a mistake there, or it wasn't exactly a mistake, but it turns out for the particular activities going on on my computer. I have too much here and not enough there. Well, I need to reallocate things. I will shuffle that around. Okay. Now, what's actually in the operating system in terms of functionality? What can it do? The generic answer to that is as much as is necessary, as little as possible. Now, the reason we want as much as is necessary, because if you don't have what's necessary, well, then your operating system cannot provide the services the user needs. The reason we want as little as possible is because, remember, this code must be correct. It must not crash. It must not do things other than what it is supposed to do, what the definitions of its system calls say it will do. It can't do anything else. It shouldn't do anything else. It mustn't do anything else. It's got to be correct. Further, it's got to be high performance, as we will discuss frequently throughout the course. We want our operating system to spend as little time running operating system code as it possibly can. Therefore, this code will be very, very carefully written. A characteristic of carefully written code, there are two characteristics. One, carefully written code is written by really good programmers. Two, carefully written code takes a lot longer to write than carelessly written code, even if you have very good programmers. If you really want to have an efficient, correct piece of code, you got to work at it, and that's going to take time. The more time it takes, the better the programmers you need, the more expensive it's going to be to develop that code. So it's very, very, very expensive to build operating system code. Therefore, you would like to build as little operating system code as you can get away with. So we've got to put in the operating system. Well, there are certain things that absolutely have to be there. So if you're going to use a privilege instruction, if somebody needs to use a privilege instruction, I need to put something on the network card, I need to send a message to another machine. That's interacting hardware, got to be privileged instructions to do that. So that is going to be in the operating system, the code that actually takes care of that kind of thing. Also, we're going to have these data structures that we build in the operating system. So for example, processes. Processes are an abstraction. There isn't such a thing as a process in the ISA, the CPU. So we're going to build an abstraction. The way we're going to do that is we're going to have services that can be offered by the abstraction and data that represents the state of the abstraction, such as this process is running uncharted. That's a piece of state. So we're going to have to keep track of that somewhere. We're going to keep track of that in a data structure maintained by the operating system. We don't want applications to be going in to those data structures and fiddling around with the data structures, because who knows what the hell they'll do. The operating system does things correctly. If it fiddles with data structures, it will fiddle correctly. Therefore, any code that operates on these kinds of data structures going to have to be in the operating system. If it's issues of security, issues of trustworthiness, issues of integrity of resources, like making sure you don't screw up the state of the file system on the flash drive, the operating system is going to have to do that. And if we have other things, such as let's say string manipulation, very common thing to have, I'm going to stop here for a moment. We've got some noise coming from the outside, so we'll pause. Okay, back in. If there's code that we are going to need to do for things like string manipulation or those 3D rotations of graphical objects, that's going to be code we put in libraries. We won't put that in the operating system. Why not? Well, because those things don't actually need privileged instructions. They are using data that is specific to a particular process. So only the process is going to fiddle with that data if the operating systems otherwise work properly. So we don't need to protect them. We don't, you know, if an operating, if an application wants to screw up its own data, that's the applications business. It's not the operating systems business. We don't try to protect applications from doing stupid things. We don't, as operating system developers, pretend to know what's stupid and what isn't stupid from an application point of view. Let them do what they want, as long as they don't get in the way of anybody else for the operating system. So anything that we don't actually have to implement in the operating system, even if multiple people need it, we're going to put into a library instead. Got to pause again. Okay, so generally, generally speaking, we're only going to put the code in the operating system if It really has to be in the operating system. Okay, but if you believe that, you would expect that operating systems are fairly tight, fairly small pieces of code. That's not true. In modern cases for most operating systems, they are very, very large pieces of code. They are quite heavy duty. Why that happen? Well, as we will see when we get to the issue of how we manage system calls, how we go from application code to the operating system back again. There's a fairly serious performance penalty for doing that. It costs a lot in terms of performance. And we don't want to pay that performance penalty. How do we pay it? Don't go across the system parallel boundary very often, which implies that maybe it's a good idea instead of going system call, back out again, system call, back out again, system call, back out again, to do one thing that requires three little bits of privilege instruction. Maybe the right thing to do is system call, do one, do two, do three, anything else you happen to need to do in between, go back again. The result of this is code gets pulled down into the operating system. This has happened very, very frequently in the course of the past 30 years or so, with the result that operating systems have gotten very, very much larger. They've gotten speed at the cost of size and complexity. Okay. Now, what operating systems are actually out there? There are a lot of operating systems that are sort of in principle out there, but relatively few of them are popular. Any computer you run on, unless it's some kind of special purpose device, is probably going to run one of three operating systems. Windows. Windows is the most popular operating system in the world. Everybody is running on Windows, to a four-story approximation, not entirely, but it's really popular. If you're running any kind of personal computer, whether it be a desktop or a laptop, and in many cases, even things like a tablet, you're probably going to be running Windows. Once in a while, they also get used in servers, and sometimes they get used in very, very small devices, things that are pretty much Internet of Things stuff. But their basic bread and butter is all of the computers that people use personally, where there's a person working with the computer directly. This isn't entirely true because of course a fairly popular operating system is Mac OS. And the particular use for Mac OS is personal computers, computers that people work with. Now this is something where there is a matter of taste. There are people who really love the Windows way of doing things and people who really love the Mac OS way of doing things. And it's often the case that if you're in one of those camps, you stay in that camp for your entire life and you don't move to the other camp. Or if you do, you don't keep moving back and forth. Certainly you tend not to have computers that you use frequently that are one type or the other, and you switch back and forth frequently. That doesn't tend to happen. You're a Mac person or you're a Windows person. Now in particular, Mac OS is designed to work in Apple products. It pretty much only works in Apple products. However, it works in all Apple products. Mac OS has been designed to fit in everything all the way from the most powerful desktop machines that they build all the way down to the watches that you wear on your wrist. All of them are running some version of Mac OS. Now then there's Linux. Linux is, of course, an open source operating system, so it is the choice of computer nerds everywhere, because you can, in principle at least, fiddle with the code of your operating system, though most people never do. There's also people who believe that it is simply a better architecture for an operating system. A matter of opinion, perhaps. But the one place where Linux is very, very widely used is in industrial servers, and in particular in the cloud computing environment. And the reason for that is that Linux has worked particularly hard on supporting high performance. They put rather less emphasis on a fun user experience and rather more on high performance. Now, if you're talking about cloud computing, high performance is the goal. That's what you want. So many, many, many cloud environments run Linux servers. And we use it in embedded systems as well, because you can frequently manage to have a stripped down version of it that will fit in a very small device. OK, so in conclusion for today's lecture, you are taking this class, I hope, because you need to understand more about computer systems, about how computers really work. And if you want to know how computers work, you've got to know how operating systems work at some level of detail. Operating systems are important because that's what's working with the hardware. That's where you have an interaction between software and hardware most directly. And another issue, which we didn't bring up too much, but we will talk about more, is that it's very important for operating system interfaces to maintain stability. So from one version of an operating system to another, things must be stable. Why is that? Remember that system call interface? The system call interface says, this is what the operating system will do for you. If the new version of the operating system doesn't support a system call that is in the old version of the operating system, any software that ran on the old version of the operating system that uses that system call won't run on the new version of the operating system. How happy would you be if when you did an upgrade on your operating system on your computer, suddenly all of your applications wouldn't work? Not very. People have expressed this kind of unhappiness in the past. So we maintain stable interfaces. And we will talk more about the issue of interface stability and how we build interfaces in the next class.